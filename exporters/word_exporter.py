#!/usr/bin/env python3
"""
Word Exporter for YMYL Audit Tool

Converts markdown reports to Microsoft Word documents with professional formatting.
FIXED: Enhanced Google Docs compatibility - imports cleanly without raw markdown.
"""

import io
import re
from typing import Optional
from docx import Document
from docx.shared import Inches, RGBColor, Pt
from docx.enum.style import WD_STYLE_TYPE
from docx.enum.text import WD_ALIGN_PARAGRAPH, WD_PARAGRAPH_ALIGNMENT
from docx.enum.dml import MSO_THEME_COLOR_INDEX
from utils.logging_utils import setup_logger

logger = setup_logger(__name__)


class WordExporter:
    """
    Converts markdown reports to professionally formatted Word documents.
    
    Features:
    - Professional document styling
    - Google Docs import compatibility
    - Color-coded severity indicators
    - Proper heading hierarchy
    - Clean bullet point formatting
    """
    
    def __init__(self):
        """Initialize the Word exporter."""
        logger.info("WordExporter initialized")

    def convert(self, markdown_content: str, title: str = "YMYL Compliance Audit Report") -> bytes:
        """
        Convert markdown content to Word document.
        
        Args:
            markdown_content (str): Markdown content to convert
            title (str): Document title
            
        Returns:
            bytes: Word document as bytes
        """
        try:
            logger.info(f"Converting markdown to Word document ({len(markdown_content):,} characters)")
            
            # Create new document
            doc = Document()
            
            # Set up document properties and styles
            self._setup_document_properties(doc, title)
            self._create_custom_styles(doc)
            
            # Parse and add content
            self._parse_markdown_content(doc, markdown_content)
            
            # Add footer with page numbers
            self._add_footer(doc)
            
            # Save to memory
            doc_buffer = io.BytesIO()
            doc.save(doc_buffer)
            doc_buffer.seek(0)
            
            logger.info("Word document conversion successful")
            return doc_buffer.getvalue()
            
        except Exception as e:
            logger.error(f"Word conversion error: {e}")
            return self._create_error_document(str(e))

    def _setup_document_properties(self, doc: Document, title: str):
        """
        Set up document properties and metadata.
        ENHANCED: Better compatibility settings for Google Docs import
        
        Args:
            doc (Document): Word document
            title (str): Document title
        """
        # Set document properties
        properties = doc.core_properties
        properties.title = title
        properties.author = "YMYL Audit Tool"
        properties.subject = "YMYL Compliance Analysis Report"
        properties.category = "Compliance Report"
        properties.comments = "Generated by AI-powered YMYL compliance analysis system"
        
        # Set up better default paragraph formatting for Google Docs compatibility
        normal_style = doc.styles['Normal']
        normal_style.font.name = 'Calibri'
        normal_style.font.size = Pt(11)
        normal_style.paragraph_format.space_after = Pt(6)
        normal_style.paragraph_format.line_spacing = 1.15

    def _create_custom_styles(self, doc: Document):
        """
        Create custom styles for the document that work better with Google Docs.
        FIXED: Use built-in Word styles that Google Docs recognizes better
        
        Args:
            doc (Document): Word document
        """
        styles = doc.styles
        
        # Only add truly custom styles, use built-ins for headers
        
        # Processing Summary Style - make it more subtle
        if 'Processing Summary' not in [s.name for s in styles]:
            summary_style = styles.add_style('Processing Summary', WD_STYLE_TYPE.PARAGRAPH)
            summary_style.base_style = styles['Normal']
            summary_style.font.name = 'Calibri'
            summary_style.font.size = Pt(10)
            summary_style.font.color.rgb = RGBColor(108, 117, 125)  # Muted gray
            summary_style.font.italic = True
            summary_style.paragraph_format.space_before = Pt(3)
            summary_style.paragraph_format.space_after = Pt(3)

    def _parse_markdown_content(self, doc: Document, markdown_content: str):
        """
        Parse markdown content and add to document.
        FIXED: Better Google Docs compatibility with proper paragraph handling
        
        Args:
            doc (Document): Word document
            markdown_content (str): Markdown content to parse
        """
        lines = markdown_content.split('\n')
        in_processing_summary = False
        skip_next_empty = False
        
        for i, line in enumerate(lines):
            original_line = line
            line = line.strip()
            
            # Skip empty lines after headers to prevent extra spacing
            if not line:
                if skip_next_empty:
                    skip_next_empty = False
                    continue
                # Add paragraph break for intentional empty lines only if previous wasn't empty
                if i > 0 and lines[i-1].strip():
                    doc.add_paragraph()
                continue
            
            # Track processing summary section
            if line.startswith('## Processing Summary'):
                in_processing_summary = True
                paragraph = doc.add_paragraph(line[3:])
                paragraph.style = 'Heading 1'  # Use built-in heading style
                skip_next_empty = True
                continue
            elif line.startswith('##') and in_processing_summary:
                in_processing_summary = False
            
            # Handle different markdown elements with better Google Docs compatibility
            if line.startswith('# '):
                # Main title - use built-in Title style
                paragraph = doc.add_paragraph(line[2:])
                paragraph.style = 'Title'  # Use Word's built-in Title style
                skip_next_empty = True
                
            elif line.startswith('## '):
                # Section heading - use built-in Heading 1
                paragraph = doc.add_paragraph(line[3:])
                paragraph.style = 'Heading 1'  # Use Word's built-in heading
                skip_next_empty = True
                
            elif line.startswith('### '):
                # Subsection heading - use built-in Heading 2
                paragraph = doc.add_paragraph(line[4:])
                paragraph.style = 'Heading 2'  # Use Word's built-in heading
                skip_next_empty = True
                
            elif line.startswith('#### '):
                # Sub-subsection heading - use built-in Heading 3
                paragraph = doc.add_paragraph(line[5:])
                paragraph.style = 'Heading 3'
                skip_next_empty = True
                
            elif line.startswith('**') and line.endswith('**') and len(line) > 4:
                # Bold text - handle as separate paragraph
                p = doc.add_paragraph()
                run = p.add_run(line[2:-2])
                run.bold = True
                
            elif line.startswith('- ') or line.startswith('* '):
                # Bullet points - use built-in List Bullet style
                bullet_text = line[2:]
                # Handle bolded parts within bullet points
                if '**' in bullet_text:
                    p = doc.add_paragraph(style='List Bullet')
                    self._add_formatted_text_to_paragraph(p, bullet_text)
                else:
                    doc.add_paragraph(bullet_text, style='List Bullet')
                    
            elif line.startswith('---'):
                # Horizontal rule - add more space and a subtle separator
                doc.add_paragraph()
                p = doc.add_paragraph('_' * 50)  # Underscore line
                p.alignment = WD_ALIGN_PARAGRAPH.CENTER
                run = p.runs[0]
                run.font.color.rgb = RGBColor(192, 192, 192)  # Light gray
                doc.add_paragraph()
                
            elif self._contains_severity_indicator(line):
                # Severity indicators - handle with proper formatting
                p = doc.add_paragraph()
                self._add_severity_formatted_text(p, line)
                        
            else:
                # Regular paragraph
                if line:
                    # Handle paragraphs with embedded formatting
                    if '**' in line:
                        p = doc.add_paragraph()
                        if in_processing_summary:
                            p.style = 'Processing Summary'
                        self._add_formatted_text_to_paragraph(p, line)
                    else:
                        style_name = 'Processing Summary' if in_processing_summary else 'Normal'
                        doc.add_paragraph(line, style=style_name)

    def _add_formatted_text_to_paragraph(self, paragraph, text):
        """
        Add text with embedded bold formatting to a paragraph.
        Handles **bold** markers properly for Google Docs compatibility.
        """
        # Split text by bold markers
        parts = re.split(r'(\*\*.*?\*\*)', text)
        
        for part in parts:
            if part.startswith('**') and part.endswith('**') and len(part) > 4:
                # Bold text
                run = paragraph.add_run(part[2:-2])
                run.bold = True
            elif part:
                # Regular text
                paragraph.add_run(part)

    def _add_severity_formatted_text(self, paragraph, text):
        """
        Add severity indicator text with proper formatting and color.
        FIXED: Replace emojis with text for better Google Docs compatibility
        """
        # Replace emoji with text for better Word/Google Docs compatibility
        emoji_replacements = {
            'ðŸ”´': '[CRITICAL]',
            'ðŸŸ ': '[HIGH]', 
            'ðŸŸ¡': '[MEDIUM]',
            'ðŸ”µ': '[LOW]',
            'âœ…': '[âœ“]',
            'âŒ': '[âœ—]',
            'âš ï¸': '[!]'
        }
        
        # Apply emoji replacements
        display_text = text
        severity_color = None
        
        for emoji, replacement in emoji_replacements.items():
            if emoji in display_text:
                display_text = display_text.replace(emoji, replacement)
                # Set color based on severity
                if emoji == 'ðŸ”´':
                    severity_color = RGBColor(231, 76, 60)  # Red
                elif emoji == 'ðŸŸ ':
                    severity_color = RGBColor(230, 126, 34)  # Orange
                elif emoji == 'ðŸŸ¡':
                    severity_color = RGBColor(243, 156, 18)  # Yellow/Gold
                elif emoji == 'ðŸ”µ':
                    severity_color = RGBColor(52, 152, 219)  # Blue
        
        # Add the text with formatting
        if '**' in display_text:
            self._add_formatted_text_to_paragraph(paragraph, display_text)
        else:
            run = paragraph.add_run(display_text)
        
        # Apply severity color to the entire paragraph
        if severity_color:
            for run in paragraph.runs:
                run.font.color.rgb = severity_color
                run.bold = True  # Make severity indicators bold

    def _contains_severity_indicator(self, line: str) -> bool:
        """
        Check if line contains severity indicators.
        
        Args:
            line (str): Line to check
            
        Returns:
            bool: True if contains severity indicators
        """
        return any(indicator in line for indicator in ['ðŸ”´', 'ðŸŸ ', 'ðŸŸ¡', 'ðŸ”µ', 'âœ…', 'âŒ'])

    def _get_severity_style(self, line: str) -> Optional[str]:
        """
        Get appropriate style for severity line.
        NOTE: Not used in new implementation, kept for backward compatibility
        
        Args:
            line (str): Line with severity indicator
            
        Returns:
            str or None: Style name or None
        """
        if 'ðŸ”´' in line:
            return 'Critical Severity'
        elif 'ðŸŸ ' in line:
            return 'High Severity'
        elif 'ðŸŸ¡' in line:
            return 'Medium Severity'
        elif 'ðŸ”µ' in line:
            return 'Low Severity'
        return None

    def _add_footer(self, doc: Document):
        """
        Add footer with page numbers.
        
        Args:
            doc (Document): Word document
        """
        try:
            # Add footer
            footer = doc.sections[0].footer
            footer_para = footer.paragraphs[0]
            footer_para.text = "YMYL Compliance Audit Report - Page "
            
            # This is a simplified footer - full page numbering requires more complex setup
            footer_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
            footer_para.style.font.size = Pt(9)
            footer_para.style.font.color.rgb = RGBColor(127, 140, 141)
            
        except Exception as e:
            logger.warning(f"Could not add footer: {e}")

    def _create_table_from_markdown(self, doc, table_text):
        """
        Create a properly formatted table that Google Docs will import cleanly.
        """
        lines = table_text.strip().split('\n')
        if len(lines) < 2:
            return
        
        # Parse table structure
        header_row = [cell.strip() for cell in lines[0].split('|') if cell.strip()]
        
        if not header_row:
            return
        
        # Create table
        table = doc.add_table(rows=1, cols=len(header_row))
        table.style = 'Table Grid'  # Use built-in table style
        
        # Add header
        for i, header in enumerate(header_row):
            cell = table.cell(0, i)
            cell.text = header
            # Make header bold
            for paragraph in cell.paragraphs:
                for run in paragraph.runs:
                    run.bold = True
        
        # Add data rows (skip separator line if exists)
        data_start = 2 if len(lines) > 1 and '-' in lines[1] else 1
        
        for line in lines[data_start:]:
            row_data = [cell.strip() for cell in line.split('|') if cell.strip()]
            if len(row_data) == len(header_row):
                row = table.add_row()
                for i, data in enumerate(row_data):
                    row.cells[i].text = data

    def _create_error_document(self, error_message: str) -> bytes:
        """
        Create error Word document.
        
        Args:
            error_message (str): Error description
            
        Returns:
            bytes: Error document as bytes
        """
        try:
            doc = Document()
            doc.add_heading('Export Error', 0)
            doc.add_paragraph(f'Failed to convert report: {error_message}')
            doc.add_paragraph('Please try again or contact support if the problem persists.')
            
            doc_buffer = io.BytesIO()
            doc.save(doc_buffer)
            doc_buffer.seek(0)
            return doc_buffer.getvalue()
            
        except Exception as e:
            logger.error(f"Error creating error document: {e}")
            # Return minimal error document
            return b"Error creating Word document"

    def validate_markdown(self, markdown_content: str) -> bool:
        """
        Validate markdown content before conversion.
        
        Args:
            markdown_content (str): Markdown to validate
            
        Returns:
            bool: True if valid, False otherwise
        """
        try:
            if not markdown_content or not markdown_content.strip():
                return False
            
            # Check for extremely long content that might cause issues
            if len(markdown_content) > 1000000:  # 1MB limit for Word
                logger.warning(f"Markdown content very large: {len(markdown_content):,} characters")
            
            return True
            
        except Exception as e:
            logger.error(f"Markdown validation error: {e}")
            return False

    def get_document_info(self, markdown_content: str) -> dict:
        """
        Get information about the document to be created.
        
        Args:
            markdown_content (str): Markdown content
            
        Returns:
            dict: Document information
        """
        try:
            lines = markdown_content.split('\n')
            
            # Count different elements
            headings = len([line for line in lines if line.strip().startswith('#')])
            paragraphs = len([line for line in lines if line.strip() and not line.strip().startswith('#') and not line.strip().startswith('-')])
            bullet_points = len([line for line in lines if line.strip().startswith('-') or line.strip().startswith('*')])
            severity_indicators = len([line for line in lines if self._contains_severity_indicator(line)])
            
            return {
                'total_lines': len(lines),
                'headings': headings,
                'paragraphs': paragraphs,
                'bullet_points': bullet_points,
                'severity_indicators': severity_indicators,
                'estimated_pages': max(1, len(markdown_content) // 3000),  # Rough estimate
                'character_count': len(markdown_content),
                'word_count_estimate': len(markdown_content.split()),
                'google_docs_compatible': True  # NEW: Indicates this version is optimized for Google Docs
            }
            
        except Exception as e:
            logger.error(f"Error getting document info: {e}")
            return {
                'total_lines': 0,
                'headings': 0,
                'paragraphs': 0,
                'bullet_points': 0,
                'severity_indicators': 0,
                'estimated_pages': 1,
                'character_count': 0,
                'word_count_estimate': 0,
                'google_docs_compatible': True,
                'error': str(e)
            }

logger.debug("WordExporter initialized")