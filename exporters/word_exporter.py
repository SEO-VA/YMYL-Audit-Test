#!/usr/bin/env python3
"""
Word Exporter for YMYL Audit Tool

Converts markdown reports to Microsoft Word documents with professional formatting.
"""

import io
import re
from typing import Optional
from docx import Document
from docx.shared import Inches, RGBColor, Pt
from docx.enum.style import WD_STYLE_TYPE
from docx.enum.text import WD_ALIGN_PARAGRAPH, WD_PARAGRAPH_ALIGNMENT
from docx.enum.dml import MSO_THEME_COLOR_INDEX
from utils.logging_utils import setup_logger

logger = setup_logger(__name__)


class WordExporter:
    """
    Converts markdown reports to professionally formatted Word documents.
    
    Features:
    - Professional document styling
    - Consistent formatting
    - Table of contents support
    - Color-coded severity indicators
    - Page numbering and headers
    """
    
    def __init__(self):
        """Initialize the Word exporter."""
        logger.info("WordExporter initialized")

    def convert(self, markdown_content: str, title: str = "YMYL Compliance Audit Report") -> bytes:
        """
        Convert markdown content to Word document.
        
        Args:
            markdown_content (str): Markdown content to convert
            title (str): Document title
            
        Returns:
            bytes: Word document as bytes
        """
        try:
            logger.info(f"Converting markdown to Word document ({len(markdown_content):,} characters)")
            
            # Create new document
            doc = Document()
            
            # Set up document properties
            self._setup_document_properties(doc, title)
            
            # Create custom styles
            self._create_custom_styles(doc)
            
            # Parse and add content
            self._parse_markdown_content(doc, markdown_content)
            
            # Add footer with page numbers
            self._add_footer(doc)
            
            # Save to memory
            doc_buffer = io.BytesIO()
            doc.save(doc_buffer)
            doc_buffer.seek(0)
            
            logger.info("Word document conversion successful")
            return doc_buffer.getvalue()
            
        except Exception as e:
            logger.error(f"Word conversion error: {e}")
            return self._create_error_document(str(e))

    def _setup_document_properties(self, doc: Document, title: str):
        """
        Set up document properties and metadata.
        
        Args:
            doc (Document): Word document
            title (str): Document title
        """
        # Set document properties
        properties = doc.core_properties
        properties.title = title
        properties.author = "YMYL Audit Tool"
        properties.subject = "YMYL Compliance Analysis Report"
        properties.category = "Compliance Report"
        properties.comments = "Generated by AI-powered YMYL compliance analysis system"

    def _create_custom_styles(self, doc: Document):
        """
        Create custom styles for the document.
        
        FIXED: Added existence checks to prevent duplicate style errors
        
        Args:
            doc (Document): Word document
        """
        styles = doc.styles
        
        # Report Title Style
        if 'Report Title' not in [s.name for s in styles]:
            title_style = styles.add_style('Report Title', WD_STYLE_TYPE.PARAGRAPH)
            title_style.font.name = 'Calibri'
            title_style.font.size = Pt(24)
            title_style.font.bold = True
            title_style.font.color.rgb = RGBColor(44, 62, 80)  # Dark blue
            title_style.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER
            title_style.paragraph_format.space_after = Pt(18)

        # Section Heading Style
        if 'Section Heading' not in [s.name for s in styles]:
            section_style = styles.add_style('Section Heading', WD_STYLE_TYPE.PARAGRAPH)
            section_style.font.name = 'Calibri'
            section_style.font.size = Pt(16)
            section_style.font.bold = True
            section_style.font.color.rgb = RGBColor(52, 73, 94)  # Darker blue
            section_style.paragraph_format.space_before = Pt(12)
            section_style.paragraph_format.space_after = Pt(6)

        # Subsection Heading Style
        if 'Subsection Heading' not in [s.name for s in styles]:
            subsection_style = styles.add_style('Subsection Heading', WD_STYLE_TYPE.PARAGRAPH)
            subsection_style.font.name = 'Calibri'
            subsection_style.font.size = Pt(14)
            subsection_style.font.bold = True
            subsection_style.font.color.rgb = RGBColor(52, 73, 94)
            subsection_style.paragraph_format.space_before = Pt(8)
            subsection_style.paragraph_format.space_after = Pt(4)

        # Critical Severity Style
        if 'Critical Severity' not in [s.name for s in styles]:
            critical_style = styles.add_style('Critical Severity', WD_STYLE_TYPE.PARAGRAPH)
            critical_style.font.name = 'Calibri'
            critical_style.font.size = Pt(11)
            critical_style.font.bold = True
            critical_style.font.color.rgb = RGBColor(231, 76, 60)  # Red

        # High Severity Style
        if 'High Severity' not in [s.name for s in styles]:
            high_style = styles.add_style('High Severity', WD_STYLE_TYPE.PARAGRAPH)
            high_style.font.name = 'Calibri'
            high_style.font.size = Pt(11)
            high_style.font.bold = True
            high_style.font.color.rgb = RGBColor(230, 126, 34)  # Orange

        # Medium Severity Style
        if 'Medium Severity' not in [s.name for s in styles]:
            medium_style = styles.add_style('Medium Severity', WD_STYLE_TYPE.PARAGRAPH)
            medium_style.font.name = 'Calibri'
            medium_style.font.size = Pt(11)
            medium_style.font.bold = True
            medium_style.font.color.rgb = RGBColor(243, 156, 18)  # Yellow/Gold

        # Low Severity Style
        if 'Low Severity' not in [s.name for s in styles]:
            low_style = styles.add_style('Low Severity', WD_STYLE_TYPE.PARAGRAPH)
            low_style.font.name = 'Calibri'
            low_style.font.size = Pt(11)
            low_style.font.bold = True
            low_style.font.color.rgb = RGBColor(52, 152, 219)  # Blue

        # Processing Summary Style
        if 'Processing Summary' not in [s.name for s in styles]:
            summary_style = styles.add_style('Processing Summary', WD_STYLE_TYPE.PARAGRAPH)
            summary_style.font.name = 'Calibri'
            summary_style.font.size = Pt(10)
            summary_style.font.color.rgb = RGBColor(127, 140, 141)  # Gray
            summary_style.paragraph_format.space_before = Pt(6)

    def _parse_markdown_content(self, doc: Document, markdown_content: str):
        """
        Parse markdown content and add to document.
        
        Args:
            doc (Document): Word document
            markdown_content (str): Markdown content to parse
        """
        lines = markdown_content.split('\n')
        in_processing_summary = False
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # Track processing summary section
            if line.startswith('## Processing Summary'):
                in_processing_summary = True
                doc.add_heading(line[3:], level=2).style = 'Section Heading'
                continue
            elif line.startswith('##') and in_processing_summary:
                in_processing_summary = False
            
            # Handle different markdown elements
            if line.startswith('# '):
                # Main title
                paragraph = doc.add_paragraph(line[2:])
                paragraph.style = 'Report Title'
                
            elif line.startswith('## '):
                # Section heading
                paragraph = doc.add_paragraph(line[3:])
                paragraph.style = 'Section Heading'
                
            elif line.startswith('### '):
                # Subsection heading
                paragraph = doc.add_paragraph(line[4:])
                paragraph.style = 'Subsection Heading'
                
            elif line.startswith('**') and line.endswith('**'):
                # Bold text
                p = doc.add_paragraph()
                run = p.add_run(line[2:-2])
                run.bold = True
                
            elif line.startswith('- ') or line.startswith('* '):
                # Bullet points
                doc.add_paragraph(line[2:], style='List Bullet')
                
            elif line.startswith('---'):
                # Horizontal rule (add space)
                doc.add_paragraph()
                
            elif self._contains_severity_indicator(line):
                # Severity indicators
                style_name = self._get_severity_style(line)
                paragraph = doc.add_paragraph(line)
                if style_name:
                    paragraph.style = style_name
                    
            else:
                # Regular paragraph
                if line:
                    style_name = 'Processing Summary' if in_processing_summary else 'Normal'
                    doc.add_paragraph(line, style=style_name)

    def _contains_severity_indicator(self, line: str) -> bool:
        """
        Check if line contains severity indicators.
        
        Args:
            line (str): Line to check
            
        Returns:
            bool: True if contains severity indicators
        """
        return any(indicator in line for indicator in ['ðŸ”´', 'ðŸŸ ', 'ðŸŸ¡', 'ðŸ”µ', 'âœ…', 'âŒ'])

    def _get_severity_style(self, line: str) -> Optional[str]:
        """
        Get appropriate style for severity line.
        
        Args:
            line (str): Line with severity indicator
            
        Returns:
            str or None: Style name or None
        """
        if 'ðŸ”´' in line:
            return 'Critical Severity'
        elif 'ðŸŸ ' in line:
            return 'High Severity'
        elif 'ðŸŸ¡' in line:
            return 'Medium Severity'
        elif 'ðŸ”µ' in line:
            return 'Low Severity'
        return None

    def _add_footer(self, doc: Document):
        """
        Add footer with page numbers.
        
        Args:
            doc (Document): Word document
        """
        try:
            # Add footer
            footer = doc.sections[0].footer
            footer_para = footer.paragraphs[0]
            footer_para.text = "YMYL Compliance Audit Report - Page "
            
            # This is a simplified footer - full page numbering requires more complex setup
            footer_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
            footer_para.style.font.size = Pt(9)
            footer_para.style.font.color.rgb = RGBColor(127, 140, 141)
            
        except Exception as e:
            logger.warning(f"Could not add footer: {e}")

    def _create_error_document(self, error_message: str) -> bytes:
        """
        Create error Word document.
        
        Args:
            error_message (str): Error description
            
        Returns:
            bytes: Error document as bytes
        """
        try:
            doc = Document()
            doc.add_heading('Export Error', 0)
            doc.add_paragraph(f'Failed to convert report: {error_message}')
            doc.add_paragraph('Please try again or contact support if the problem persists.')
            
            doc_buffer = io.BytesIO()
            doc.save(doc_buffer)
            doc_buffer.seek(0)
            return doc_buffer.getvalue()
            
        except Exception as e:
            logger.error(f"Error creating error document: {e}")
            # Return minimal error document
            return b"Error creating Word document"

    def validate_markdown(self, markdown_content: str) -> bool:
        """
        Validate markdown content before conversion.
        
        Args:
            markdown_content (str): Markdown to validate
            
        Returns:
            bool: True if valid, False otherwise
        """
        try:
            if not markdown_content or not markdown_content.strip():
                return False
            
            # Check for extremely long content that might cause issues
            if len(markdown_content) > 1000000:  # 1MB limit for Word
                logger.warning(f"Markdown content very large: {len(markdown_content):,} characters")
            
            return True
            
        except Exception as e:
            logger.error(f"Markdown validation error: {e}")
            return False

    def get_document_info(self, markdown_content: str) -> dict:
        """
        Get information about the document to be created.
        
        Args:
            markdown_content (str): Markdown content
            
        Returns:
            dict: Document information
        """
        try:
            lines = markdown_content.split('\n')
            
            # Count different elements
            headings = len([line for line in lines if line.strip().startswith('#')])
            paragraphs = len([line for line in lines if line.strip() and not line.strip().startswith('#') and not line.strip().startswith('-')])
            bullet_points = len([line for line in lines if line.strip().startswith('-') or line.strip().startswith('*')])
            
            return {
                'total_lines': len(lines),
                'headings': headings,
                'paragraphs': paragraphs,
                'bullet_points': bullet_points,
                'estimated_pages': max(1, len(markdown_content) // 3000),  # Rough estimate
                'character_count': len(markdown_content),
                'word_count_estimate': len(markdown_content.split())
            }
            
        except Exception as e:
            logger.error(f"Error getting document info: {e}")
            return {
                'total_lines': 0,
                'headings': 0,
                'paragraphs': 0,
                'bullet_points': 0,
                'estimated_pages': 1,
                'character_count': 0,
                'word_count_estimate': 0
            }

logger.debug("WordExporter initialized")